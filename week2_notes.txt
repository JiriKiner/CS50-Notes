Process of compiling

1st - Preprocessing
 - checks for #include stuff and inputs the functions in them which I am using in my code (stdio.h, cs50.h, etc.)

2nd - Compiling
 - changes the code to instructions for the CPU (assembly)

3nd - Assembling
 - change the instructions to binary

4th - Linking
 - change the libraries to binary and link all the binary code to one file


buggy0.c

int main(void)
{
	printf("hello, world\n")
}


buggy2.c

#include <stdio.h>

int main(void)
{
	for (int i = 0; i <= 10; i++)
	}
		printf("i is %i\n", i);
		printf("#\n");
	}
}


Debugging Tools

help50 - to help with error messages and wrong code
printf - to see what is actuatlly happening at the particular place
style50 - to see if it is nice looking code


RAM

 - Random Access Memory


Arrays

 - stored back to back to back in memory


scores0.c

#include <stdio.h>
#include <cs50.h>

void chart(int score);

int main(void)
{
	int score1 = get_int("Score 1: ");
	int score2 = get_int("Score 2: ");
	int score3 = get_int("Score 3: ");

	printf("Score 1: ");
	chart(score1);

	printf("Score 2: ");
	chart(score2);

	printf("Score 3: ");
	chart(score3);
}

void chart(int score)
{
	for (int i = 0; i < score; i++)
	{
		printf("#");
	}
	printf("\n");
}


scores2.c

// Generates a bar chart of three scores using an array

#include <stdio.h>
#include <cs50.h>

const int COUNT = 3;

void chart(int score);

int main(void)
{
	// Get scores from user
	int scores[COUNT];
	for (int i = 0; i < COUNT; i++)
	{
		scores[i] = get_int("Score %i: ", i + 1);
	}

	// Chart scores
	for (int i = 0; i < COUNT; i++)
	{
		printf("Score %i: ", i + 1);
		chart(scores[i]);
	}
}

void chart(int score)
{
	for (int i = 0; i < score; i++)
	{
		printf("#");
	}
	printf("\n");
}

(notes:
 - if the variable is named with capital letters, that means it is declared at the beginning of the code and it is global, accessible everywhere (outside the curly braces)
)


scores4.c

// Generates a bar chart of three scores by passing an array, using a constant

#include <stdio.h>
#include <cs50.h>
#include <math.h>

const int COUNT = 3;

void chart(int count, int scores[]);

int main(void)
{
	// Get scores from user
	int scores[COUNT];
	for (int i = 0; i < COUNT; i++)
	{
		scores[i] = get_int("Score %i: ", i + 1);
	}

	// Chart scores
	chart(COUNT, scores);
}

// Generate bars

void chart(int count, int scores[])
{
	// Output one hash per point
	for (int i = 0; i < count; i++)
	{
		for(int j = 0; j < scores[i]; j++)
		{
			printf("#");
		}
		printf("\n");
	}
}


string0.c

// Prints string char by char

#include <stdio.h>
#include <cs50.h>
#include <string.h>

int main(void)
{
	string s = get_string("Input :");
	printf("Output:\n");
	for (int i = 0, n = strlen(s); i < n; i++)
	{
		printf("%c\n", s[i]);
	}
}

(notes:
 - including the string.h library will unlock string related functions, for example strlen, which will return the length of the string
)


Null Terminator

 - for the computer to know where in the memory it stored the variable, string, etc. it is putting identifier in the first byte that it starts here and at the end of the variable it puts one byte of zeros (00000000 or \0) known as null terminator


strlen.c

#include <stdio.h>
#include <cs50.h>
#include <string.h>

int main(void)
{
	string s = get_string("Name: ");

	int n = 0;
	while (s[n] != '\0')
	{
		n++;
	}

	printf("The length of your name is %i\n", n);
}


ascii0.c

// Explicitly casts chars to ints

#include <stdio.h>
#include <cs50.h>
#include <string.h>

int main(void)
{
	string s = get_string("String: ");
	for (int = 0; i < strlen(s); i++)
	{
		int c = (int) s[i];	// I even don't have to specify (int), I can just write int c = s[i]
		printf("%c %i\n", s[i], c); // I can even exclude the whole line above and just type printf("%c %i\n", s[i], s[i]);
	}
}

(notes:
 - the default code is called explicit casting and if I will use the methods in the comments, that is called implicit casting
)

capitalize0.c

// Capitalizes a string

#include <stdio.h>
#include <cs50.h>
#include <string.h>

int main(void)
{
	string s = get_string("Before: ");
	printf("After: ");
	for (int i = 0, n = strlen(s); i < n; i++)
	{
		if (s[i] >= 'a' && s[i] <= 'z')
		{
			printf("%c", s[i] - ('a' - 'A'));	// Subtracts the ASCII value of the lower letter from capital letter, which is 32 for all letters, and then subtracts the value (32) from my letter
		}
		else
		{
			printf("%c", s[i]);
		}
	}
	printf("\n");
}


capitalize1.c

// Capitalizes string using ctype library (and an unnecessary condition)

#include <stdio.h>
#include <cs50.h>
#include <string.h>
#include <ctype.h>

int main(void)
{
	string s = get_string("Before: ");
	printf("After: ");
	for (int i = 0, n = strlen(s); i < n; i++)
	{
		printf("%c", toupper(s[i]));
	}
	printf("\n");
}


argv0.c

#include <stdio.h>
#include <cs50.h>

int main(int argc, string argv[])
{
	if (argc == 2)
	{
		printf("hello, %s\n", argv[1]);
	}
	else
	{
		printf("hello, world\n");
	}
}


argv1.c

#include <stdio.h>
#include <cs50.h>
#include <string.h>

int main(int argc, string argv[])
{
	// Iterate over strings in argv
	for (int i = 0; i < argc; i++)
	{
		// Iterate over chars in argv[i]
		for (int j = 0, n = strlen(argv[i]); j < n; j++)
		{
			printf("%c\n", argv[i][j]);
		}
	}
}


Ciphering


exit.c

// Returns explicit value from main

#include <stdio.h>
#include <cs50.h>

int main(in argc, string argv[])
{
	if (arc != 2)
	{
		printf("missing command-line argument\n");
		return 1;
	}
	printf("hello, %s\n", argv[1]);
	return 0;
}

(notes:
 - if I want to retroactively see what value main returned, I can run this command after the program ends - echo $?
 - if you don't specify return value, program will automatically return value 0, because 0 means that everything did well. If something went wrong, you want to return different value.
)


Finding 50

Computer can't see in the all arrays at once, just to one


Sorting on Stage

In array of randomized numbers, I can do few algorithms to sort them out.


Bubble Sort

Compare each pair from left to right and then move the smaller number of the two to the left. When some number on the end is on the good position, I can remove it from the checks.


Selection Sort

Check the whole array from left to right, take the smallest number and move it at the beginning. Then remove the number it self and it's position from the checking and moving.


Computational Complexity

(n-1) + (n-2) + (n-3).... +1
n(n-1)/2
(n2-n)/2
n2/2 - n/2
O(n2)
O(log n)


Merge sort

Dividing the array in halfs until you have array of one character and then sorting it and moving into another empty arrays in right order.


Comparing Sorts Visually


Shorts


Functions

We can write our functions to use them multiple times without writing them again and again in the main code, which will be unwieldy.
C and nearlz all languages developed since allow us to write functions, sometimes also known as procedures, methods (object oriented languages), or subroutines.

- Function is a black box with a set of 0+ inputs and 1 output
- It is called a black box, because we don't need to see what is inside and what it does, we just need the output
- Using of them allows to organize better. They help break up a complicated problem into more manageable subparts
- Simplification - smaller components tend to be easier to design, implement and debug

Function Declarations

- The first step to creating a function is to declare it. This gives the compiler a heads-up that a user-written function appears in the code
- Function declarations should always go atop the code, before begin writing main()
- There is a standard form that every function declaration follows

	return-type name(argument-list);
- The return-type is what kind of variable the function will output
- The name is what you want to call your function
- The argument-list is the comma-separated set of inputs to your function, each of which has a type and a name

example:
float mult_two_reals(float x, float y);

Function Definitions

- The second step to creating a function is to define it. This allows for predictable behavior when the function is called with inputs

example:
float mult_two_reals(float x, float y)
{
	float product = x * y;
	return product;
}

or

float mult_two_reals(float x, float y)
{
	return x * y;
}

Function Calls

- To call a function, simply pass it appropriate arguments and assign its return value to something of the correct type

Function Miscellany

- Functions can sometimes take no inputs. In that case, we declare the function as having a void argument list
- Functions sometimes do not have an output. In that case, we declare the function as having a void return type


Arrays

